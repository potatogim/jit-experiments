define: DEFINITE_TYPES TypeDouble|TypeInt|TypeUnsignedInt|TypeAny
define: ARITH_BINOPS   pj_binop_add|pj_binop_multiply
define: LOGICAL_BINOPS pj_binop_bool_and|pj_binop_bool_or
define: NUM_COMPARISON pj_binop_num_eq|pj_binop_num_ne|pj_binop_num_lt|pj_binop_num_gt|pj_binop_num_le|pj_binop_num_ge
define: UNOPS          pj_unop_perl_int|pj_unop_negate

name: Expr
match: DOUBLE_Expr
match: INT_Expr

name: INT_Expr
match: UINT_Expr

name: RootExpr
match: Expr

name: RootExpr
match: Optree
emit_llvm: {
  $$ = _jit_emit_root_optree(state);
}

name: RootExpr
match: OPAQUE_Expr
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: Expr
match: Optree
emit_llvm: {
  $$ = _jit_emit_optree(state);
}

name: Expr
match: BOOL_Expr @ $OP
emit_llvm: {
  $$ = EmitValue(_bool_to_scalar_value(_($OP).value), &SCALAR_T);
}

name: INT_Expr
match: BOOL_Expr

# Statements

name: Expr
match: AstStatement(Expr @ $E) @ $OP
weight: 2
delay: $E
emit_llvm: {
  $$ = _jit_emit_statement((Statement *) $OP.term, __($E));
}

name: Expr
match: AstStatement(Optree @ $O)
weight: 1
delay: $O
emit_llvm: {
  $$ = _jit_emit_root_optree(__($O));
}

# Constants

name: RootExpr
match: AstConst(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstConst(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &DOUBLE_T);
}

name: INT_Expr
match: AstConst(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &INT_T);
}

name: UINT_Expr
match: AstConst(TypeUnsignedInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &UNSIGNED_INT_T);
}

# Lexicals

name: RootExpr
match: AstLexical(DEFINITE_TYPES)
match: AstLexicalDeclaration(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstLexical(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: DOUBLE_Expr
match: AstLexicalDeclaration(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: INT_Expr
match: AstLexical(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: INT_Expr
match: AstLexicalDeclaration(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: OPAQUE_Expr
match: AstLexical(TypeOpaque)
match: AstLexicalDeclaration(TypeOpaque)

name: Expr
match: AstLexical(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: Expr
match: AstLexicalDeclaration(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

# Arithmetic unary

name: INT_Expr
match: AstUnop(UNOPS, DOUBLE_Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

name: UNSIGNED_INT_Expr
match: AstUnop(UNOPS, INT_Expr @ $A) @ $OP
emit_llvm: {
  $$ = EmitValue(_($A).value, &UNSIGNED_INT_T);
}

name: OPAQUE_Expr
match: AstUnop(UNOPS, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstUnop(UNOPS, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

# Logical not

name: BOOL_Expr
match: AstUnop(pj_unop_bool_not, DOUBLE_Expr @ $A) @ $OP
match: AstUnop(pj_unop_bool_not, INT_Expr @ $A) @ $OP
match: AstUnop(pj_unop_bool_not, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &INT_T);
}

name: OPAQUE_Expr
match: AstUnop(pj_unop_bool_not, OPAQUE_Expr)

# Arithmetic binary

name: DOUBLE_Expr
match: AstBinop(ARITH_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(ARITH_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(ARITH_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstBinop(ARITH_BINOPS, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Numeric comparison

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(NUM_COMPARISON, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(NUM_COMPARISON, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(NUM_COMPARISON, OPAQUE_Expr, Expr)
match: AstBinop(NUM_COMPARISON, Expr, OPAQUE_Expr)
match: AstBinop(NUM_COMPARISON, OPAQUE_Expr, OPAQUE_Expr)

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Logical binary

name: DOUBLE_Expr
match: AstBinop(LOGICAL_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(LOGICAL_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(LOGICAL_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &SCALAR_T);
}

# Ternary

name: DOUBLE_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, OPAQUE_Expr, Expr)
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr, OPAQUE_Expr)
match: AstListop(pj_listop_ternary, Expr @ $COND, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &SCALAR_T);
}
