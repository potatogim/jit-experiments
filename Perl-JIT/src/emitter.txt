name: Expr
match: DOUBLE_Expr
match: INT_Expr

name: INT_Expr
match: UINT_Expr

name: RootExpr
match: Expr

name: RootExpr
match: Optree
emit_llvm: {
  $$ = _jit_emit_root_optree(state);
}

name: RootExpr
match: OPAQUE_Expr
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: Expr
match: Optree
emit_llvm: {
  $$ = _jit_emit_optree(state);
}

# Constants

name: RootExpr
match: AstConst(TypeDouble)
match: AstConst(TypeInt)
match: AstConst(TypeUnsignedInt)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstConst(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &DOUBLE_T);
}

name: INT_Expr
match: AstConst(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &INT_T);
}

name: UINT_Expr
match: AstConst(TypeUnsignedInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &UNSIGNED_INT_T);
}

# Lexicals

name: RootExpr
match: AstLexical(TypeDouble)
match: AstLexical(TypeInt)
match: AstLexical(TypeAny)
match: AstLexicalDeclaration(TypeDouble)
match: AstLexicalDeclaration(TypeInt)
match: AstLexicalDeclaration(TypeAny)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstLexical(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: DOUBLE_Expr
match: AstLexicalDeclaration(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: INT_Expr
match: AstLexical(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: INT_Expr
match: AstLexicalDeclaration(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: OPAQUE_Expr
match: AstLexical(TypeOpaque)
match: AstLexicalDeclaration(TypeOpaque)

name: Expr
match: AstLexical(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: Expr
match: AstLexicalDeclaration(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

# Arithmetic unary

name: INT_Expr
match: AstUnop(pj_unop_perl_int, DOUBLE_Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

name: UNSIGNED_INT_Expr
match: AstUnop(pj_unop_perl_int, INT_Expr @ $A) @ $OP
emit_llvm: {
  $$ = EmitValue(_($A).value, &UNSIGNED_INT_T);
}

name: OPAQUE_Expr
match: AstUnop(pj_unop_perl_int, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstUnop(pj_unop_perl_int, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

# Arithmetic binary

name: DOUBLE_Expr
match: AstBinop(pj_binop_add, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_add, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
match: AstBinop(pj_binop_multiply, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_multiply, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(pj_binop_add, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_add, Expr @ $A, INT_Expr @ $B) @ $OP
match: AstBinop(pj_binop_multiply, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_multiply, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(pj_binop_add, OPAQUE_Expr, Expr)
match: AstBinop(pj_binop_add, Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_add, OPAQUE_Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_multiply, OPAQUE_Expr, Expr)
match: AstBinop(pj_binop_multiply, Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_multiply, OPAQUE_Expr, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstBinop(pj_binop_add, Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_multiply, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Logical binary

name: DOUBLE_Expr
match: AstBinop(pj_binop_bool_and, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_and, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_or, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_or, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(pj_binop_bool_and, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_and, Expr @ $A, INT_Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_or, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_or, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(pj_binop_bool_and, OPAQUE_Expr, Expr)
match: AstBinop(pj_binop_bool_and, Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_bool_and, OPAQUE_Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_bool_or, OPAQUE_Expr, Expr)
match: AstBinop(pj_binop_bool_or, Expr, OPAQUE_Expr)
match: AstBinop(pj_binop_bool_or, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstBinop(pj_binop_bool_and, Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_bool_or, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &SCALAR_T);
}
