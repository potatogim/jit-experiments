define: DEFINITE_TYPES TypeDouble|TypeInt|TypeUnsignedInt|TypeAny
define: ARITH_BINOPS   pj_binop_add|pj_binop_multiply
define: LOGICAL_BINOPS pj_binop_bool_and|pj_binop_bool_or
define: NUM_COMPARISON pj_binop_num_eq|pj_binop_num_ne|pj_binop_num_lt|pj_binop_num_gt|pj_binop_num_le|pj_binop_num_ge
define: UNOPS          pj_unop_perl_int|pj_unop_negate

name: Expr
match: DOUBLE_Expr
match: INT_Expr

name: INT_Expr
match: UINT_Expr

name: RootExpr
match: Expr

name: RootExpr
match: Optree
emit_llvm: {
  $$ = _jit_emit_root_optree(state);
}

name: RootExpr
match: OPAQUE_Expr
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: Expr
match: Optree
emit_llvm: {
  $$ = _jit_emit_optree(state);
}

name: Expr
match: BOOL_Expr @ $OP
emit_llvm: {
  $$ = EmitValue(_bool_to_scalar_value(_($OP).value), &SCALAR_T);
}

name: INT_Expr
match: BOOL_Expr

# Statements

name: Expr
match: AstStatement(Expr @ $E) @ $OP
weight: 2
delay: $E
emit_llvm: {
  $$ = _jit_emit_statement((Statement *) $OP.term, __($E));
}

name: Expr
match: AstStatement(Optree @ $O)
weight: 1
delay: $O
emit_llvm: {
  $$ = _jit_emit_root_optree(__($O));
}

name: Expr
match: AstStatement(OPAQUE_Expr)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

# Constants

name: RootExpr
match: AstConst(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstConst(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &DOUBLE_T);
}

name: INT_Expr
match: AstConst(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &INT_T);
}

name: UINT_Expr
match: AstConst(TypeUnsignedInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &UNSIGNED_INT_T);
}

# Lexicals

name: RootExpr
match: AstLexical(DEFINITE_TYPES)
match: AstLexicalDeclaration(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstLexical(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: DOUBLE_Expr
match: AstLexicalDeclaration(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: INT_Expr
match: AstLexical(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: INT_Expr
match: AstLexicalDeclaration(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: OPAQUE_Expr
match: AstLexical(TypeOpaque)
match: AstLexicalDeclaration(TypeOpaque)

name: Expr
match: AstLexical(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: Expr
match: AstLexicalDeclaration(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

# Arithmetic unary

name: INT_Expr
match: AstUnop(UNOPS, DOUBLE_Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

name: UNSIGNED_INT_Expr
match: AstUnop(UNOPS, INT_Expr @ $A) @ $OP
emit_llvm: {
  $$ = EmitValue(_($A).value, &UNSIGNED_INT_T);
}

name: OPAQUE_Expr
match: AstUnop(UNOPS, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstUnop(UNOPS, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

# Logical not

name: BOOL_Expr
match: AstUnop(pj_unop_bool_not, DOUBLE_Expr @ $A) @ $OP
match: AstUnop(pj_unop_bool_not, INT_Expr @ $A) @ $OP
match: AstUnop(pj_unop_bool_not, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &INT_T);
}

name: OPAQUE_Expr
match: AstUnop(pj_unop_bool_not, OPAQUE_Expr)

# Arithmetic binary

name: DOUBLE_Expr
match: AstBinop(ARITH_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(ARITH_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(ARITH_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstBinop(ARITH_BINOPS, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Numeric comparison

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(NUM_COMPARISON, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(NUM_COMPARISON, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(NUM_COMPARISON, OPAQUE_Expr, Expr)
match: AstBinop(NUM_COMPARISON, Expr, OPAQUE_Expr)
match: AstBinop(NUM_COMPARISON, OPAQUE_Expr, OPAQUE_Expr)

name: BOOL_Expr
match: AstBinop(NUM_COMPARISON, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_num_comparison((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Logical binary

name: DOUBLE_Expr
match: AstBinop(LOGICAL_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(LOGICAL_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(LOGICAL_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &SCALAR_T);
}

# Assignment

name: Expr
match: AstBinop(pj_binop_sassign, Expr @ $A, Optree @ $B) @ $OP
delay: $A
emit_llvm: {
  if (((Binop *) $OP.term)->is_synthesized_assignment()) {
    $$ = EmitValue(OPTREE, &SCALAR_T);
  } else {
    reduce(__($A));
    // when matching Optree directly this is required (in other cases
    // it's the Optree -> Expr step that does the emission
    $$ = _jit_emit_sassign(_($A), _jit_emit_optree(__($B)));
  }
}

name: Expr
match: AstBinop(pj_binop_sassign, Expr @ $A, Expr @ $B)
emit_llvm: {
  $$ = _jit_emit_sassign(_($A), _($B));
}

name: OPAQUE_Expr
match: AstBinop(pj_binop_sassign, OPAQUE_Expr, Expr)
match: AstBinop(pj_binop_sassign, Expr, OPAQUE_Expr)

# Array access

name: Expr
match: AstBinop(pj_binop_aelem, Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_aelem, Expr @ $A, OPAQUE_Expr @ $B) @ $OP
match: AstBinop(pj_binop_aelem, OPAQUE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(pj_binop_aelem, OPAQUE_Expr @ $A, OPAQUE_Expr @ $B) @ $OP
emit_llvm: {
  OP *o = $OP.term->get_perl_op();
  bool is_aelem = o->op_type == OP_AELEM;
  // TODO does not handle OPpLVAL_MAYBE (lvaue sub return value)
  bool is_lvalue = o->op_flags & OPf_MOD;
  bool is_deferred = is_aelem ? o->op_private & OPpLVAL_DEFER : false;
  bool is_localizing = is_aelem ? o->op_private & OPpLVAL_INTRO : false;
  bool is_deref = is_aelem ? o->op_private & OPpDEREF : false;

  $$ = _jit_emit_array_fetch(_($A), _($B), is_lvalue, is_deref, is_deferred, is_localizing);
}

# Ternary

name: DOUBLE_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, OPAQUE_Expr, Expr)
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr, OPAQUE_Expr)
match: AstListop(pj_listop_ternary, Expr @ $COND, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstListop(pj_listop_ternary, Expr @ $COND, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_ternary((Listop *) $OP.term, _($COND), __($A), __($B), &SCALAR_T);
}
