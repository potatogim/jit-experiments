#!/usr/bin/env perl

use t::lib::Perl::JIT::Test;

my %ops = map {$_ => { name => $_ }} qw(
  not and or cond_expr eq ne lt le gt ge
);

# FIXME the 1+ prefixes in the tests are to protect the scalar assignments from
#       the ANY return types of some of the logops.
my @tests = (
  { name   => 'wrapped: boolean not false to true',
    func   => build_jit_test_sub('$a', 'my $x = 1 + !$a;', '$x'),
    opgrep => [$ops{not}],
    output => 2,
    input  => [0], },
  { name   => 'wrapped: boolean not true to false',
    func   => build_jit_test_sub('$a', 'my $x = 1 + !$a;', '$x'),
    opgrep => [$ops{not}],
    output => 1,
    input  => [1], },
  { name   => 'boolean not false to true',
    func   => build_jit_test_sub('$a', 'my $x = !$a;', '$x'),
    opgrep => [$ops{not}],
    output => 1,
    input  => [0], },
  { name   => 'boolean not true to false',
    func   => build_jit_test_sub('$a', 'my $x = !$a;', '$x'),
    opgrep => [$ops{not}],
    output => '',
    input  => [1], },

  { name   => 'wrapped-boolean and: yes with types',
    func   => build_jit_test_sub(undef, 'typed Int ($a, $b)=@_; my $x = 1+($a && $b);', '$x'),
    opgrep => [$ops{and}],
    output => 1000,
    input  => [99, 999], },
  { name   => 'wrapped-boolean and: right no',
    func   => build_jit_test_sub('$a, $b', 'my $x = 1+($a && $b);', '$x'),
    opgrep => [$ops{and}],
    output => 1,
    input  => [2, 0], },
  { name   => 'boolean and: yes',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a && $b);', '$x'),
    opgrep => [$ops{and}],
    output => 999,
    input  => [99, 999], },
  { name   => 'boolean and: left no',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a and $b);', '$x'),
    opgrep => [$ops{and}],
    output => 0,
    input  => [0, 9999], },
  { name   => 'boolean and: right no',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a && $b);', '$x'),
    opgrep => [$ops{and}],
    output => 0,
    input  => [2, 0], },

  { name   => 'wrapped-boolean or: right with types',
    func   => build_jit_test_sub(undef, 'typed Int ($a, $b)=@_; my $x = 1+($a || $b);', '$x'),
    opgrep => [$ops{or}],
    output => 1000,
    input  => [0, 999], },
  { name   => 'wrapped-boolean or: left',
    func   => build_jit_test_sub('$a, $b', 'my $x = 1+($a or $b);', '$x'),
    opgrep => [$ops{or}],
    output => 3,
    input  => [2, 42], },
  { name   => 'boolean or: right',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a || $b);', '$x'),
    opgrep => [$ops{or}],
    output => 999,
    input  => [0, 999], },
  { name   => 'boolean or: left',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a || $b);', '$x'),
    opgrep => [$ops{or}],
    output => 2,
    input  => [2, 42], },
  { name   => 'boolean or: no',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a || $b);', '$x'),
    opgrep => [$ops{or}],
    output => 0,
    input  => [0, 0], },

  { name   => 'wrapped-ternary: left with types',
    func   => build_jit_test_sub(undef, 'typed Int ($a, $b, $c)=@_; my $x = 1+($a ? $b : $c);', '$x'),
    opgrep => [$ops{cond_expr}],
    output => 3,
    input  => [1, 2, 3], },
  { name   => 'wrapped-ternary: left',
    func   => build_jit_test_sub('$a, $b, $c', 'my $x = 1+($a ? $b : $c);', '$x'),
    opgrep => [$ops{cond_expr}],
    output => 3,
    input  => [1, 2, 3], },
  { name   => 'ternary: left with types',
    func   => build_jit_test_sub(undef, 'typed Int ($a, $b, $c)=@_; my $x = ($a ? $b : $c);', '$x'),
    opgrep => [$ops{cond_expr}],
    output => 2,
    input  => [1, 2, 3], },
  { name   => 'ternary: right',
    func   => build_jit_test_sub('$a, $b, $c', 'my $x = ($a ? $b : $c);', '$x'),
    opgrep => [$ops{cond_expr}],
    output => 3,
    input  => [0, 2, 3], },
  { name   => 'ternary: left',
    func   => build_jit_test_sub('$a, $b, $c', 'my $x = ($a ? $b : $c);', '$x'),
    opgrep => [$ops{cond_expr}],
    output => 2,
    input  => [1, 2, 3], },
  { name   => 'complex boolean - or first',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a || ($b && $b));', '$x'),
    opgrep => [@ops{qw(or and)}],
    output => 9,
    input  => [0, 9], },
  { name   => 'complex boolean - and first',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a && ($b || $b));', '$x'),
    opgrep => [@ops{qw(or and)}],
    output => 9,
    input  => [7, 9], },
  { name   => 'complex ternary on true branch',
    func   => build_jit_test_sub('$a, $b, $c, $d, $e', 'my $x = ($a ? $b ? $c : $d : $e);', '$x'),
    opgrep => [@ops{qw(cond_expr)}],
    output => 3,
    input  => [1, 2, 3, 4, 5], },
  { name   => 'complex ternary on false branch',
    func   => build_jit_test_sub('$a, $b, $c, $d, $e', 'my $x = ($a ? $b : $c ? $d : $e);', '$x'),
    opgrep => [@ops{qw(cond_expr)}],
    output => 4,
    input  => [0, 2, 3, 4, 5], },
  { name   => 'num ==, int, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => 1,
    input  => [1, 1], },
  { name   => 'num ==, int, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => '',
    input  => [1, 2], },
  { name   => 'num ==, float, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => 1,
    input  => [1.123, 1.123], },
  { name   => 'num ==, float, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => '',
    input  => [1.123, 2.123], },
  { name   => 'num ==, typed int, true',
    func   => build_jit_test_sub(undef, 'typed Int ($a, $b)=@_; my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => 1,
    input  => [42, 42], },
  { name   => 'num ==, typed double, false',
    func   => build_jit_test_sub(undef, 'typed Double ($a, $b)=@_; my $x = ($a == $b);', '$x'),
    opgrep => [$ops{eq}],
    output => '',
    input  => [43, 42.123], },
  { name   => 'num !=, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a != $b);', '$x'),
    opgrep => [$ops{ne}],
    output => '',
    input  => [1, 1], },
  { name   => 'num !=, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a != $b);', '$x'),
    opgrep => [$ops{ne}],
    output => 1,
    input  => [1, 2], },
  { name   => 'num <, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a < $b);', '$x'),
    opgrep => [$ops{lt}],
    output => '',
    input  => [1, 1], },
  { name   => 'num <, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a < $b);', '$x'),
    opgrep => [$ops{lt}],
    output => 1,
    input  => [1, 2], },
  { name   => 'num <=, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a <= $b);', '$x'),
    opgrep => [$ops{le}],
    output => 1,
    input  => [1.1, 1.1], },
  { name   => 'num <=, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a <= $b);', '$x'),
    opgrep => [$ops{le}],
    output => '',
    input  => [3, 2], },
  { name   => 'num >, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a > $b);', '$x'),
    opgrep => [$ops{gt}],
    output => 1,
    input  => [3.1, 1], },
  { name   => 'num >, false',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a > $b);', '$x'),
    opgrep => [$ops{gt}],
    output => '',
    input  => [1, 1], },
  { name   => 'num >=, true',
    func   => build_jit_test_sub('$a, $b', 'no warnings; my $x = ($a >= $b);', '$x'),
    opgrep => [$ops{ge}],
    output => 1,
    input  => ["123asd", 2], },
  { name   => 'num >=, true',
    func   => build_jit_test_sub('$a, $b', 'my $x = ($a >= $b);', '$x'),
    opgrep => [$ops{ge}],
    output => 1,
    input  => [2, 2], },
  { name   => 'bool -> int coercion',
    func   => build_jit_test_sub('$a, $b', 'my $x = 1 + ($a >= $b);', '$x'),
    opgrep => [$ops{ge}, {name => 'add'}],
    output => 2,
    input  => [2, 2], },
);

# save typing
$_->{output} //= 42 for @tests;

plan tests => count_jit_tests(\@tests);

run_jit_tests(\@tests);

