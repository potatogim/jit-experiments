Perl opcodes that are still todo or possibly todo/reconsider

scalar		scalar			ck_fun		s%	S
pushmark	pushmark		ck_null		s0	

# What else can a const be? Likely done
const		constant item		ck_svconst	s$	

gvsv		scalar variable		ck_null		ds$	
gv		glob value		ck_null		ds$	
gelem		glob elem		ck_null		d2	S S
padany		private value		ck_null		d0

pushre		push regexp		ck_null		d/

rv2cv		subroutine dereference	ck_rvconst	d1

#done?
refgen		reference constructor	ck_spair	m1	L
srefgen		single ref constructor	ck_null		fs1	S

# glob defaults its first arg to $_
glob		glob			ck_glob		t@	S?
rcatline	append I/O operator	ck_null		t$

regcmaybe	regexp internal guard	ck_fun		s1	S
regcreset	regexp internal reset	ck_fun		s1	S
regcomp		regexp compilation	ck_null		s|	S
qr		pattern quote (qr//)	ck_match	s/
substcont	substitution iterator	ck_null		dis|	
trans		transliteration (tr///)	ck_match	is"	S
# y///r
transr		transliteration (tr///)	ck_match	is"	S

stringify	string			ck_fun		fsT@	S

smartmatch	smart match		ck_smartmatch	s2

hslice		hash slice		ck_null		m@	H L
boolkeys	boolkeys		ck_fun		%	H

# requires thinking?
list		list			ck_null		m@	L

sort		sort			ck_sort		dm@	C? L
# reverse is "done", but requires thinking for sort
reverse		reverse			ck_fun		mt@	L

range		flipflop		ck_null		|	S S
flip		range (or flip)		ck_null		1	S S
flop		range (or flop)		ck_null		1

method		method lookup		ck_method	d1
entersub	subroutine entry	ck_subr		dmt1	L
leavesub	subroutine exit		ck_null		1	
leavesublv	lvalue subroutine return	ck_null		1	

dbstate		debug next statement	ck_null		s;	
method_named	method with known name	ck_null		d$

entergiven	given()			ck_null		d|
leavegiven	leave given block	ck_null		1
enterwhen	when()			ck_null		d|
leavewhen	leave when block	ck_null		1
break		break			ck_null		0
continue	continue		ck_null		0

enterwrite	write			ck_fun		dis%	F?
leavewrite	write exit		ck_null		1	

hintseval	eval hints		ck_svconst	s$
entereval	eval "string"		ck_eval		du%	S?
leaveeval	eval "string" exit	ck_null		1	S
#evalonce	eval constant string	ck_null		d1	S
entertry	eval {block}		ck_eval		d|	
leavetry	eval {block} exit	ck_null		@	

custom		unknown custom operator		ck_null		0

# For CORE:: subs
coreargs	CORE:: subroutine	ck_null		$	

runcv		__SUB__			ck_null		s0

# fc and \F
fc		fc			ck_fun		fstu%	S?
