%module{Perl::JIT};

#include "pj_ast_terms.h"
#include "xsp_typedefs.h"

/* map op to B::*OP class name */
#include "opclass.h"

class Perl::JIT::AST::Term {
  pj_term_type type %get %set;
  OP *perl_op %get %set;
  OP *start_op();
  OP *first_op();
  OP *last_op();
  Perl::JIT::AST::Type *get_value_type();
  std::vector<Perl::JIT::AST::Term *> get_kids()
    %code{% PERL_UNUSED_VAR(THIS); %};
  pj_op_context context();

  void dump();
};

class Perl::JIT::AST::Empty : public Perl::JIT::AST::Term
{
};

class Perl::JIT::AST::List : public Perl::JIT::AST::Term
{
  std::vector<Perl::JIT::AST::Term *> kids %get;
};

class Perl::JIT::AST::Op : public Perl::JIT::AST::Term
{
  pj_op_type optype %get %set;
  std::vector<Perl::JIT::AST::Term *> kids %get;

  const char * name() const;
  pj_op_class op_class() const;
  bool is_integer_variant() const;

  bool evaluates_kids_conditionally() const
    %code{% RETVAL = THIS->flags() & PJ_ASTf_KIDS_CONDITIONAL; %};

  bool kids_are_optional() const
    %code{% RETVAL = THIS->flags() & PJ_ASTf_KIDS_OPTIONAL; %};

  bool may_have_explicit_overload() const
    %code{% RETVAL = THIS->flags() & PJ_ASTf_OVERLOAD; %};
};

class Perl::JIT::AST::Baseop : public Perl::JIT::AST::Op
{};

class Perl::JIT::AST::Unop : public Perl::JIT::AST::Op
{
  Perl::JIT::AST::Term *get_kid() %code{% RETVAL = THIS->kids[0]; %};
  void set_kid(Perl::JIT::AST::Term *k) %code{% THIS->kids[0] = k; %};
};

class Perl::JIT::AST::Binop : public Perl::JIT::AST::Op
{
  bool is_assignment_form();
  bool is_synthesized_assignment();

  Perl::JIT::AST::Term *get_left_kid() %code{% RETVAL = THIS->kids[0]; %};
  void set_left_kid(Perl::JIT::AST::Term *k) %code{% THIS->kids[0] = k; %};

  Perl::JIT::AST::Term *get_right_kid() %code{% RETVAL = THIS->kids[1]; %};
  void set_right_kid(Perl::JIT::AST::Term *k) %code{% THIS->kids[1] = k; %};
};

class Perl::JIT::AST::Listop : public Perl::JIT::AST::Op
{};

class Perl::JIT::AST::Block : public Perl::JIT::AST::Op
{};

class Perl::JIT::AST::BareBlock : public Perl::JIT::AST::Term
{
  Perl::JIT::AST::Term *body %get;
  Perl::JIT::AST::Term *continuation %get;

  std::vector<Perl::JIT::AST::Term *> get_kids();
};

class Perl::JIT::AST::While : public Perl::JIT::AST::Term
{
  Perl::JIT::AST::Term *condition %get;
  bool negated %get;
  bool evaluate_after %get;
  Perl::JIT::AST::Term *body %get;
  Perl::JIT::AST::Term *continuation %get;

  std::vector<Perl::JIT::AST::Term *> get_kids();
};

class Perl::JIT::AST::For : public Perl::JIT::AST::Term
{
  Perl::JIT::AST::Term *init %get;
  Perl::JIT::AST::Term *condition %get;
  Perl::JIT::AST::Term *step %get;
  Perl::JIT::AST::Term *body %get;

  std::vector<Perl::JIT::AST::Term *> get_kids();
};

class Perl::JIT::AST::Foreach : public Perl::JIT::AST::Term
{
  Perl::JIT::AST::Term *iterator %get;
  Perl::JIT::AST::Term *expression %get;
  Perl::JIT::AST::Term *body %get;
  Perl::JIT::AST::Term *continuation %get;

  std::vector<Perl::JIT::AST::Term *> get_kids();
};

class Perl::JIT::AST::Map : public Perl::JIT::AST::Term
{
  Perl::JIT::AST::Term *body %get;
  Perl::JIT::AST::List *parameters %get;

  std::vector<Perl::JIT::AST::Term *> get_kids();
};

class Perl::JIT::AST::Constant : public Perl::JIT::AST::Term
{
  pj_type_id const_type() %code{% RETVAL = THIS->get_value_type()->tag(); %};
};

class Perl::JIT::AST::NumericConstant : public Perl::JIT::AST::Constant
{
  double dbl_value %get %set;
  int int_value %get %set;
  unsigned int uint_value %get %set;
};

class Perl::JIT::AST::StringConstant : public Perl::JIT::AST::Constant
{
  std::string string_value %get %set;
  bool is_utf8 %get %set;
};

class Perl::JIT::AST::UndefConstant : public Perl::JIT::AST::Constant
{
};

class Perl::JIT::AST::Identifier : public Perl::JIT::AST::Term
{
};

class Perl::JIT::AST::VariableDeclaration : public Perl::JIT::AST::Identifier
{
  int ivar %get %set;
  pj_variable_sigil sigil %get;
  int get_pad_index() %code{% RETVAL = THIS->perl_op->op_targ; %};
};

class Perl::JIT::AST::Lexical : public Perl::JIT::AST::Identifier
{
  Perl::JIT::AST::VariableDeclaration *declaration %get;
  int get_ivar() const %code{% RETVAL = THIS->declaration->ivar; %};
  pj_variable_sigil get_sigil() const %code{% RETVAL = THIS->declaration->sigil; %};
  int get_pad_index();
};

class Perl::JIT::AST::Global : public Perl::JIT::AST::Identifier
{
  pj_variable_sigil sigil %get;
#ifdef USE_ITHREADS
  int get_pad_index() const;
#else
  GV *get_gv() const;
#endif
};

class Perl::JIT::AST::Optree : public Perl::JIT::AST::Term
{
};

class Perl::JIT::AST::NullOptree : public Perl::JIT::AST::Term
{
};

class Perl::JIT::AST::Statement : public Perl::JIT::AST::Term
{
  std::vector<Perl::JIT::AST::Term *> kids %get;
  Perl::JIT::AST::Term *get_kid() %code{% RETVAL = THIS->kids[0]; %};
  void set_kid(Perl::JIT::AST::Term *k) %code{% THIS->kids[0] = k; %};
};

class Perl::JIT::AST::StatementSequence : public Perl::JIT::AST::Term
{
  std::vector<Perl::JIT::AST::Term *> kids %get;
};
